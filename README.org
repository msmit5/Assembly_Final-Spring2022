#+TITLE: FINAL 2022

* Instructions:
Welcome to the Final Exam!

You have been hired as a Contractor by Stark Industries to help with the development of the Jarvis-2022 Bomb Sight.

Your job will be be write the most critical elements of the Bomb Sight Code. 

These include the elements that will retrieve the target data, calculate the drop solution and finally pass the data on for use by other systems.

Good Luck Tony Stark is watching!

** Detailed instructions with extra info

The angle of the Target from the Aircraft is A1 and the angle of the Aircraft relative to the vertical y is 90-A1.

The direct distance of the Aircraft to the Target or Range is d.

The Aircraft drops the ordnance, allowing it to free fall to the target.

The Aircraft is traveling a a speed of Vx m/s.

The important equations are;

1.  y=d*cos(90-A1), where A1 is in degrees

2.  x=d*sin(90-A1), where A1 is in degrees

3.  y=0.5*a*t^2, where a=9.8 m/s^2

4.  x'=Vx*t

The vertical distance above ground is measured by a radar altimeter and provided in meters.

Given the knowns above x', t and d can be solved for.

Note x' does not equal x.

x' is the distance the ordinance will travel in time t (the time the ordinance is in free fall).

x is the current x distance to the target.

1a. d=y/cos(90-A1)

2a. From 1a and 1 above solve for x

3a. y is given solve for t or t=sqrt(2y/a)

The cos(x) and sin(x) can be solved for from a Taylor Series Expansion.

sin(x)=(-1^n/(2*n+1)!)*x^(2*n+1) for n=0...

cos(x)=(-1^n/(2*n)!)*x^(2*n) for n=0...

Note x above is in radians where 2*PI radians = 360 degrees...all angles need to be converted to radians from degrees and back!

To restate the following data is provided to the Jarvis-2022.

1.  Vx i m/s

2. y in m

3. A1 in degrees

Data will be received as ASC encoded characters in a buffer in the following format;

"UPDATE A1:XXX DEGREES, Y XXX METERS, VX XXX M/S"

Where the X's indicate ASC digits for the A1, Y and VX values.

The input string must be decoded to extract the required data for calculations.

For the exam simply create test buffers for use in testing your application.

The output of the Jarvis-2022 must be another ASC buffer in the following format;

"SOLUTION DROP IN XXX SECS"

Where XXX represents the drop time in seconds.

The drop time is the time given by (x-x')/Vx and represents the time delay required to ensure when the ordinance is dropped that it will free fall on to the target.

Note if the drop time is negative this represents the case where the Aircraft is too close for a free fall drop.

The output should be "SOLUTION ABORT!" in this case.

Your application should support a test mode to allow the input of the target data from STDIN (keyboard) and display the results to STDOUT (monitor).

Test mode should be entered by the user inputting 'TEST' from STDIN (keyboard).

Test mode should be exited by the user inputting 'NORMAL' from STDIN (keyboard).

Please submit your s files, demo snips of your application in operation using the test mode and normal mode along with a word document detailing your design.

Submit all of your results in a single zip file.

Good Luck & have a nice summer break!

* Documentation:
** CONSTRAINTS:
- MAXIMUM NUMBER: 12! (479,001,600) is the maximum value I can print properly.
** Modules
*** exit.s
exit.s exits the program. It has multiple different versions of the function. All use raw service calls to exit.
**** exit
exit is the most simple way of exiting, and exits with an exit code of 0
#+BEGIN_SRC asm
mov r0, #0
mov r7, #1
#+END_SRC
**** exit_f
Exit syscall but with an exit code of 1
#+BEGIN_SRC asm
mov r0, #1
mov r7, #1
#+END_SRC
**** exit_c
exit syscall, but the exit code is expected in r0
***** ARGUMENTS
- r0 <-- exit code
**** exit_p
exit syscall, however we will write a message to stdout in the process.
***** ARGUMENTS
Stack:
 .
/|\ 
 |    length of error message  (pop 1) 
 |    address of error message (pop 2) 
 | 

 r0 <-- Exit code

*** write-float.s
write-float.s prints a floating point number as decimal to stdount.
**** wf_single
prints a single precision floating point to stdout. I use a very hacky way to do this, so see below for a section called "The Hack"
#+BEGIN_SRC c
wf_single(float* r0)
#+END_SRC

** Usage
** The Hack
*** write-float
The hack consists of 5 steps:
  1. Separate the integral and fractional sections of float f1
    - This is done manually, using the standard arm processor
  2. Print the integral part of f1
    - I am using the printDecimal.s to do this
  3. Take the fractional part of f1, multiply it by a power of 10 (100,000 is used in the code). Let it be f2
    - This is done in the neon floating point coprocessor
  4. Separate the integral and fractional sections of f2
    - Done in the same manner as before
  5. Print a decimal point
  6. Print the integral part of f2

* TODOs by day
** DONE (2/24) [2/3]:
- [X] Write code to display single precision floating points to stdout as ascii
- [-] Write code to display double precision floating points to stdout as ascii
- [X] DOCUMENTATION!
*** TODO Write C code as proof of concept

** TODO (2/25) [0/3]:
- [ ] Write code to read single precision floating points from stdin as ascii
- [ ] Write code to read double precision floating points from stdin as ascii
- [ ] Fix the printDecimal.s to accept larger integers, up to the maximum size of a double word (8 bytes, I'm not using x86 defs)

** TODO (2/26) [/]
*** TODO shared functions [/]
- [ ] Implement factorial.s
- [ ] Implement exponents.s
*** [/] Implement taylor series with 50 iterations for sin
- [ ] main code
- [ ] test code (use zsh)
*** [/] Implement Taylor Series with 50 iterations for cos
- [ ] main code
- [ ] test code (use zsh)

** TODO (2/27) [/]
- [ ] relax, attend class with questions
- [ ] plan out second week
